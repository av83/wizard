
+++

sbcl --lose-on-corruption --disable-ldb --dynamic-space-size 1024

(require 'asdf)
(asdf:oos 'asdf:load-op 'swank)
(setf swank::*loopback-interface* "0.0.0.0")

(swank:create-server :coding-system "utf-8-unix" :dont-close t)

(swank:create-server :coding-system "utf-8-unix" :dont-close t :port 8008)


(defun clear ()
  (loop :for var :being :the :symbols :in :wizard.impl.routes :do (unintern var))
  (restas:reconnect-all-routes))

(clear)


(restas:start '#:wizard :port 8081)
(restas:debug-mode-on)

[01:37] rigidus> я бы хотел, чтобы во время доступа (на чтение или
запись) к слоту некоего объекта вызывался метод этого объекта. куда
смотреть?
[06:03] dmitry_vk> rigidus: это можно сделать через MOP. См. методы
slot-value-using-class и (setf slot-value-using-class)


[21:09] rigidus> dmitry_vk: а что означает эта декларация? (declaim (ftype (function (integer &key (:on-error symbol))) f))
[21:09] dmitry_vk> Что f - это функция, которая принимает одно целое и
имеет ключевой параметр :on-error типа symbol
[21:10] dmitry_vk> LinkFly: хм, нет. :on-error - это имя параметра
(имя - это keyword), а symbol - его тип
[21:11] rigidus> а тип возвращаемого значения этой функции указать
можно?
[21:11] LinkFly> тогда норм:)
[21:11] dmitry_vk> Да, можно, после списка аргументов:
(ftype (function (arg-1-type .. arg-n-type) result-type))
[21:12] LinkFly> можно даже нескольких через (values result-type ...)


Кто бы там что ни говорил, а программирование под Unix не может не
радовать своей простотой. Когда я писал программы под Windows
взаимодействие с ОСью было куда менее простым и прозрачным. А если
сюда ещё добавить мощь языка Common Lisp, а также хорошую лисп-систему
(например SBCL), то разработка поднимается на принципиально другой
уровень по сравнению с традиционным программированием на Си. Ниже
представлена ф-ия безопасной записи в файл. Безопасной в том смысле,
что если несколько процессов используют её для записи в один и тот же
файл, то возможность коллизии (т.е. порчи записываемых одновременно
данных) абсолютно исключена.

(defparameter *safe-write-sleep* 0.01)
(defun safe-write (pathname string &aux stream)
  (setf stream (open pathname :direction :output :if-does-not-exist :create :if-exists :append))
  (unwind-protect
       (loop
          until (block try-lock
                  (handler-bind ((error (lambda (condition)
                                          (if (= sb-posix:eagain
                                                 (sb-posix:syscall-errno condition))
                                              (return-from try-lock)
                                              (error condition)))))
                    (sb-posix:lockf stream sb-posix:f-tlock 0)
                    (princ string stream)
                    (close stream)))
          do (sleep *safe-write-sleep*))
    (close stream)))

http://linkfly.livejournal.com/2891.html

;; Получение имени пользователя
SB-POSIX> (defun get-username (&aux (pid (getpid))) ;(getenv "USERNAME"))
           (passwd-name
            (getpwuid
             (stat-uid
              (stat (format nil "/proc/~A" pid))))))


[16:38] laser1234> (setenv "CL_SOURCE_REGISTRY"
 "(:source-registry
 (:tree \"/home/user/lisp/libs/\")
 (:tree \"/home/user/projects/\")
 :inherit-configuration)")
[16:38] laser1234> Кусок init.el
[16:38] laser1234> После этого lisp/libs/ и projects/ сканируются
рекурсивно.
[16:38] laser1234> (setenv "CL_SOURCE_REGISTRY"
 "(:source-registry
 (:tree \"/home/user/lisp/libs/\")
 (:tree \"/home/user/projects/\")
 :inherit-configuration)")
[16:38] laser1234> Кусок init.el
[16:38] laser1234> После этого lisp/libs/ и projects/ сканируются
рекурсивно.
[17:37] laser1234> Ну хорошо, тогда по старинке (push #"path/to/libs/"
asdf:*central-registry*)
[17:39] jsv> а чего через окружение, а не в
~/.config/common-lisp/source-registry.conf?
